{"version":3,"sources":["util.js","common.js","func-name-map.js","func-handle-map.js","other.js"],"names":["Array","prototype","removeByVal","val","index","indexOf","splice","removeByLastVal","lastIndexOf","removeByLastValObj","i","length","value","removeByIndex","String","replaceAll","f","e","reg","RegExp","replace","util","logg","content","console","log","errLogg","func","error","module","exports","IFELSE","BASEFUNC","shorChar","common","isState","char","current","input","str","slice","includes","isNotFunc","name","test","isBaseFunc","isExistFunc","FUNC_NAME_MAP","FUNC_HANDLE_MAP","printf","arg","lastQuoIndex","paramStr","argStr","argArr","split","percentage","argIndex","require","WHITESPACE","WORD","tokenizer","tokens","temp_index","push","type","word_str","parser","temp_ast","getAst","token","next_token","node","params","isFunc","pre_index","pre_token","ast","body","astTraver","visitor","nodeArrTraver","arr","parent","forEach","child","nodeTraver","method","transformer","newAst","_context","StringLiteral","StateLiteral","SemLiteral","WhiteLiteral","ParenbLiteral","CallExpression","expression","callee","arguments","generator","map","join","funcName","res","compiler","output"],"mappings":"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","file":"451705bfa8033273f0792c5bf35ba14b.map","sourcesContent":["// 按值删除数组中元素\nArray.prototype.removeByVal = function(val) {\n  var index = this.indexOf(val);\n  if (index > -1) {\n    this.splice(index, 1);\n  }\n};\n\n// 按值删除数组中最后一个匹配的元素\nArray.prototype.removeByLastVal = function(val) {\n  var index = this.lastIndexOf(val);\n  if (index > -1) {\n    this.splice(index, 1);\n  }\n};\n\n// 按值删除数组对象中最后一个匹配的元素\nArray.prototype.removeByLastValObj = function(val) {\n  let index = -1;\n  for(let i = 0 ; i < this.length ; i++) {\n    if(this[i].value === val) index = i;\n  }\n  if (index > -1) {\n    this.splice(index, 1);\n  }\n};\n\n// 按索引删除数组中元素\nArray.prototype.removeByIndex = function(index) {\n  this.splice(index, 1);\n};\n\n// 全部替换\nString.prototype.replaceAll = function(f, e) {\n  const reg = new RegExp(f, \"g\");  \n  return this.replace(reg, e); \n}\n\nconst util = {\n  logg: function(content) {\n    console.log('--------------------------------------------\\n');\n    console.log(content);\n    console.log();\n    console.log('--------------------------------------------\\n');\n  },\n\n  errLogg: function(func, content) {\n    console.log(\"-------------error------------\\n\");\n    console.error(`${func}: ${content}`);\n    console.log();\n    console.log('-------------error------------\\n');\n  }\n}\n\nmodule.exports = util;","const IFELSE = /^(if|else|else if)[\\s]*$/;\nconst BASEFUNC = /^(print|printf)[\\s]*$/;\nconst shorChar = ['c', 'i', 's', 'l', 'd', 'f'];\n\nconst common = {\n  isState: function(char, current, input) {\n\n    let str = input.slice(current, current + 7);\n  \n    if(str.indexOf(\"char\") != -1 || str.indexOf(\"int\") != -1 || str.indexOf(\"short\") != -1 || str.indexOf(\"long\") != -1 || str.indexOf(\"double\") != -1 || str.indexOf(\"float\") != -1 || str.indexOf(\"string\") != -1) {\n      if(!shorChar.includes(char)){\n        return false;\n      }\n      if(str.indexOf(' ') === -1) {\n        return false;\n      }\n      return true;\n    }\n\n    str = input.slice(current, current + 10);\n    if(str.indexOf(\"long long\") != -1 || str.indexOf(\"long double\") != -1) {\n      if(char != 'l') {\n        return false;\n      }\n      if(str.indexOf(' ') === -1) {\n        return false;\n      }\n      return true;\n    }\n\n    return false;\n  },\n\n  isNotFunc: function(name) {\n    if(IFELSE.test(name)) {\n      return true;\n    }\n\n    // 是函数\n    return false;\n  },\n\n  isBaseFunc: function(name) {\n    if(BASEFUNC.test(name)) {\n      return name;\n    }\n\n    return false;\n  },\n\n  isExistFunc: function(name) {\n    if(name.includes('=')) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\nmodule.exports = common;","const FUNC_NAME_MAP = {\n  'printf': 'console.log'\n}\n\nmodule.exports = FUNC_NAME_MAP;\n","const FUNC_HANDLE_MAP = {\n  printf: function(arg) {\n    let lastQuoIndex = arg.lastIndexOf('\"');\n    let paramStr = '';\n\n    // 获取后面参数，+2跳过引号和逗号, 最后再去掉空格\n    let argStr = arg.slice(lastQuoIndex + 2, arg.length).replaceAll(' ', '');\n\n    // 获取参数数组\n    let argArr = argStr.split(',')\n\n    let percentage = arg.indexOf('%');\n\n    // 起始为1跳过引号\n    let argIndex = 0;\n\n    if (percentage === -1) {\n      // 没有参数则直接返回字符串\n      paramStr = arg;\n    } else {\n      while (percentage != -1) {\n        // 用加号拼接str和参数\n        paramStr += `'${arg.slice(1, percentage)}' + ${argArr[argIndex]}`\n  \n        // 将之前的字符串截取出去\n        arg = arg.slice(percentage + 1, arg.length);\n  \n        // 获取下一个占位符\n        percentage = arg.indexOf('%');\n        \n        // 参数数组自增\n        argIndex++;\n  \n        if(percentage != -1) {\n          paramStr += ' + ';\n        }\n      }\n    }\n    \n    return paramStr;\n  }\n}\n\nmodule.exports = FUNC_HANDLE_MAP;\n","const util = require('./util');\nconst common = require('./common');\nconst FUNC_NAME_MAP = require('./func-name-map');\nconst FUNC_HANDLE_MAP = require('./func-handle-map');\n\nconst input = \n`\n#include \"stdlib.h\"\n\nint add(a,b){\n  int sum = a + b;\n  return sum;\n};\nint main() {\n  string str = \"hello world\";\n  int a = 3, b = 1;\n  int res = add(a, b);\n  if( res > a ) {\n    printf(\"the result is %d\", res);\n  } else {\n    printf(\"%s\", str);\n  };\n  return 0;\n}`\n\nconst WHITESPACE = /\\s/;\nconst WORD = /[a-z0-9 | :~,'\"%=+/\\-*/^></\\[/\\]!.]/i;\n\n// 字符串转token\nfunction tokenizer(input) {\n  // 字符串当前位置\n  let current = 0;\n\n  // 存放token\n  let tokens = [];\n\n  // 循环输入的字符串\n  while (current < input.length) {\n    \n    // 获取当前字符\n    let char = input[current];\n\n    // 检查是否为声明\n    if (common.isState(char, current, input)) {\n      // 获取声明后空格索引\n      let temp_index = input.slice(current, current + 10).indexOf(' ');\n      // 获取声明\n      \n      current = current + temp_index + 1;\n\n      tokens.push({\n        type: 'state',\n        value: 'var'\n      });\n\n      continue;\n    }\n    // 检查是否为括号\n    if (char === '(') {\n\n      // token添加\n      tokens.push({\n        type: 'paren',\n        value: '('\n      })\n      // 继续循环\n      current++;\n      continue;\n    }\n    \n    if (char === ')') {\n      tokens.push({\n        type: 'paren',\n        value: ')'\n      })\n      current++;\n      continue;\n    }\n\n    // 检查是否为大括号\n    if (char === '{') {\n      tokens.push({\n        type: 'parenb',\n        value: '{'\n      })\n      current++;\n      continue;\n    }\n\n    if (char === '}') {\n      tokens.push({\n        type: 'parenb',\n        value: '}'\n      })\n      current++;\n      continue;\n    }\n\n    // 检查是否为分号\n    if (char === ';') {\n      tokens.push({\n        type: 'semicolon',\n        value: ';'\n      })\n      current++;\n      continue;\n    }\n\n    // 检查是否为空格\n    if (WHITESPACE.test(char)) {\n      tokens.push({\n        type: 'whitespace',\n        value: ' '\n      })\n      current++;\n      continue;\n    }\n\n    // 检查是否为字符\n    if (WORD.test(char)) {\n      let word_str = '';\n\n      // 直到遇到非字符\n      while(WORD.test(char) && char) {\n        word_str += char;\n        char = input[++current];\n      }\n\n      tokens.push({\n        type: 'string',\n        value: word_str\n      })\n\n      continue;\n    }\n\n    current++;\n  }\n\n  return tokens;\n}\n\n// tokens转ast\nfunction parser(tokens) {\n  let current = 0;\n\n  let temp_ast;\n  // 递归遍历\n  function getAst() {\n    // 遍历token数组\n\n    let token = tokens[current];\n\n    // 判断是否为string类型\n    if(token.type === 'string') {\n      current++;\n      \n      // 判断后面是否为函数\n      let next_token = tokens[current];\n      if(next_token && next_token.type === 'paren' && next_token.value === '(') {\n        return null;\n      }\n\n      // 否则返回string\n      return {\n        type: 'StringLiteral',\n        value: token.value\n      }\n    }\n\n    if(token.type === 'semicolon') {\n      current++;\n\n      return {\n        type: 'SemLiteral',\n        value: token.value\n      }\n    }\n\n    if(token.type === 'whitespace') {\n      current++;\n\n      return {\n        type: 'WhiteLiteral',\n        value: token.value\n      }\n    }\n\n    // 判断是否为类型声明\n    if(token.type === 'state') {\n      current++;\n\n      return {\n        type: 'StateLiteral',\n        value: token.value\n      }\n    }\n\n    // 判断是否为大括号\n    if (token.type === 'parenb' && (token.value === '{' || token.value === '}')) {\n      current++;\n\n      return {\n        type: 'ParenbLiteral',\n        value: token.value\n      };\n    }\n\n    // 判断是否为括号\n    if(token.type === 'paren' && token.value === '(') {\n      // 创建CallExpression节点\n      let node = {\n        type: 'CallExpression',\n        params: [],\n        name: '',\n        isFunc: true,\n        isBaseFunc: true,\n        isExistFunc: false\n      }\n\n      // 获取函数名\n      let pre_index = current - 1;\n      let pre_token = tokens[pre_index];\n\n      if(pre_token.type === 'string') {\n        node.name = pre_token.value;\n\n        // 判断是否为函数\n        let isNotFunc = common.isNotFunc(node.name);\n\n        if(isNotFunc) {\n          node.isFunc = false;\n        } else {\n          // 判断是否为基本函数\n          let isBaseFunc = common.isBaseFunc(node.name);\n\n          if(!isBaseFunc) {\n            ast.body.removeByLastValObj('var');\n            node.isBaseFunc = false;\n          }\n\n          // 判断是否为已有函数\n          let isExistFunc = common.isExistFunc(node.name);\n          if(isExistFunc) {\n            node.isExistFunc = true;\n          }\n        }\n      }\n      \n      // 删除函数前面的state声明\n\n      // 跳过括号并且获取下一个token\n      token = tokens[++current];\n\n      // 继续遍历直到遇到右括号\n      while ((token.type !== 'paren') || (token.type === 'paren' && token.value !== ')')) {\n        // 参数放入params\n        node.params.push(getAst());\n        token = tokens[current];\n\n        if(!token) {\n          util.errLogg('parser过程出错', `存在括号未闭合错误<${current}>`);\n          break;\n        }\n      }\n\n      // 跳过右括号\n      current++;\n      return node;\n    }\n\n    util.errLogg('parser过程出错', `发现未知类型${token.type}`);\n\n    current++;\n    return;\n  }\n\n  // 创建ast\n  let ast = {\n    type: 'Program',\n    body: []\n  }\n\n  while(current < tokens.length) {\n    temp_ast = getAst();\n    if(temp_ast) ast.body.push(temp_ast);\n  }\n\n  return ast;\n}\n\n\n// 遍历ast处理节点\nfunction astTraver(ast, visitor) {\n\n  function nodeArrTraver(arr, parent) {\n    arr.forEach(function(child) {\n      nodeTraver(child, parent)\n    })\n  }\n\n  function nodeTraver(node, parent) {\n\n    if (!node) {\n      util.errLogg('astTraver过程出错', `括号未闭合或出现未知类型<${parent.type}>`);\n      return;\n    }\n\n    // 获取当前节点处理函数\n    let method = visitor[node.type];\n\n    if(method) {\n      method(node, parent)\n    }\n\n    switch (node.type) {\n      // 顶层，遍历其子元素数组\n      case 'Program':\n        nodeArrTraver(node.body, node);\n        break;\n      \n      // 函数, 遍历其参数数组\n      case 'CallExpression':\n        nodeArrTraver(node.params, node);\n        break;\n      \n      // string, state等没有子节点，跳过\n      case 'StringLiteral':\n        break;\n\n      case 'StateLiteral':\n        break;\n\n      case 'SemLiteral':\n        break;\n      \n      case 'WhiteLiteral':\n        break;\n\n      case 'ParenbLiteral':\n        break;\n      \n      default:\n        util.errLogg('astTraver过程出错', `发现未知类型${node.type}`);\n    }\n  }\n\n  // 从头遍历ast\n  nodeTraver(ast, null);\n}\n\n// 将ast和traver传入得到新的ast\nfunction transformer(ast) {\n  // 创建新的根节点\n  let newAst = {\n    type: 'Program',\n    body: []\n  };\n\n  // 在根节点上创建context上下文，用来存放节点\n  // context是一个引用，从旧的ast到新的\n  ast._context = newAst.body;\n\n  astTraver(ast, {\n    // 处理string\n    StringLiteral: function(node, parent) {\n      // 创建新节点放入父节点context\n      parent._context.push({\n        type: 'StringLiteral',\n        value: node.value\n      });\n    },\n\n    // 处理state\n    StateLiteral: function(node, parent) {\n      parent._context.push({\n        type: 'StateLiteral',\n        value: node.value\n      });\n    },\n\n    // 处理分号\n    SemLiteral: function(node, parent) {\n      parent._context.push({\n        type: 'SemLiteral',\n        value: node.value\n      })\n    },\n\n    // 处理空格\n    WhiteLiteral: function(node, parent) {\n      parent._context.push({\n        type: 'WhiteLiteral',\n        value: node.value\n      })\n    },\n\n    // 处理大括号\n    ParenbLiteral: function(node, parent) {\n      parent._context.push({\n        type: 'ParenbLiteral',\n        value: node.value\n      })\n    },\n\n    // 处理函数\n    CallExpression: function(node, parent) {\n      // 创建CallExpression节点，内嵌套Identifier\n      let expression = {\n        type: 'CallExpression',\n        callee: {\n          type: 'Identifier',\n          name: node.name\n        },\n        isFunc: node.isFunc,\n        isBaseFunc: node.isBaseFunc,\n        isExistFunc: node.isExistFunc,\n        arguments: []\n      };\n\n      // 在CallExpression上创建context, 他是arguments的引用\n      node._context = expression.arguments;\n\n      // 判断父节点是否为函数\n      if(parent.type != 'CallExpression') {\n        expression = {\n          type: 'ExpressionStatement',\n          expression: expression\n        }\n      }\n\n      parent._context.push(expression);\n    }\n\n  });\n\n  return newAst;\n}\n\n// 打印ast中节点拼接成字符串\nfunction generator(node) {\n  switch (node.type) {\n    // 遍历根节点所有子元素\n    case 'Program':\n      return node.body.map(generator).join('');\n    \n    // 对于ExpressionStatements，递归调用其属性并加入分号\n    case 'ExpressionStatement':\n      return (\n        generator(node.expression)\n      )\n\n    // 对于CallExpressions，我们打印出callee和左括号，然后递归调用其参数，最后加上右括号\n    case 'CallExpression':\n      let funcName = generator(node.callee);\n      let argArr = node.arguments.map(generator);\n      let res;\n\n      // 是函数\n      if(node.isFunc) {\n        if(node.isBaseFunc) {\n          // 如果是基本函数\n          let paramStr = FUNC_HANDLE_MAP[funcName](argArr.join(''));\n          res = `${FUNC_NAME_MAP[funcName]}(${paramStr})`;\n        } else if(node.isExistFunc) {\n          //如果是已存在函数\n          res = `var ${funcName}(${argArr.join(', ')})`;\n        } else {\n          res = `function ${funcName}(${argArr.join(', ')})`;\n        }\n      } else {\n        // 不是函数\n        res = `${funcName}(${argArr.join('')})`;\n      }\n\n      return res;\n  \n    // 返回name\n    case 'Identifier':\n      return node.name;\n    \n    // 返回value\n    case 'NumberLiteral':\n      return node.value;\n    \n    case 'StringLiteral':\n      return node.value;\n    \n    case 'StateLiteral':\n      return node.value + ' ';\n    \n    case 'SemLiteral':\n      return ';\\n';\n    \n    case 'WhiteLiteral':\n      return ' ';\n\n    case 'ParenbLiteral':\n      return (\n        node.value + (node.value === '{' ? '\\n' : '')\n      );\n\n    default:\n      util.errLogg('generator过程出错', `发现未知类型${node.type}`);\n  }\n}\n\nfunction compiler(input) {\n  let tokens = tokenizer(input);\n  // util.logg(tokens);\n  let ast = parser(tokens);\n  // util.logg(ast);\n  let newAst = transformer(ast);\n  // util.logg(newAst);\n  let output = generator(newAst);\n  util.logg(output);\n}\n\ncompiler(input)\n\nmodule.exports = compiler;\n"]}