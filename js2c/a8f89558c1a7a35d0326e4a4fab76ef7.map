{"version":3,"sources":["util.js","common.js","func-name-map.js","func-handle-map.js","index.js","test.js"],"names":["Array","prototype","removeByVal","val","index","indexOf","splice","removeByLastVal","lastIndexOf","removeByLastValObj","i","length","value","removeByIndex","String","replaceAll","f","e","reg","RegExp","replace","removeStrByIndex","start","end","firstStr","slice","lastStr","util","logg","content","console","log","errLogg","func","error","module","exports","NOTFUNC","BASEFUNC","shorChar","common","isState","char","current","input","str","includes","isNotFunc","name","test","isBaseFunc","isExistFunc","FUNC_NAME_MAP","FUNC_HANDLE_MAP","printf","arg","lastQuoIndex","paramStr","argStr","argArr","split","percentage","argIndex","require","WHITESPACE","WORD","NEWLINE","isParWord","tokenizer","tokens","temp_index","push","type","word_str","isArr","parser","temp_ast","getAst","token","next_token","isAssignArr","search","notAssignArr","curValue","arrValue","node","params","isFunc","pre_index","pre_token","ast","body","tempAst","astTraver","visitor","nodeArrTraver","arr","parent","forEach","child","nodeTraver","method","transformer","newAst","_context","StringLiteral","StateLiteral","SemLiteral","WhiteLiteral","LineLiteral","ParenbLiteral","CallExpression","expression","callee","arguments","notFunc","generator","map","join","funcName","res","compiler","output","document","getElementById","addEventListener","eval","err","alert"],"mappings":"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","file":"a8f89558c1a7a35d0326e4a4fab76ef7.map","sourcesContent":["// 按值删除数组中元素\nArray.prototype.removeByVal = function(val) {\n  var index = this.indexOf(val);\n  if (index > -1) {\n    this.splice(index, 1);\n  }\n};\n\n// 按值删除数组中最后一个匹配的元素\nArray.prototype.removeByLastVal = function(val) {\n  var index = this.lastIndexOf(val);\n  if (index > -1) {\n    this.splice(index, 1);\n  }\n};\n\n// 按值删除数组对象中最后一个匹配的元素\nArray.prototype.removeByLastValObj = function(val) {\n  let index = -1;\n  for(let i = 0 ; i < this.length ; i++) {\n    if(this[i].value === val) index = i;\n  }\n  if (index > -1) {\n    this.splice(index, 1);\n  }\n};\n\n// 按索引删除数组中元素\nArray.prototype.removeByIndex = function(index) {\n  this.splice(index, 1);\n};\n\n// 全部替换\nString.prototype.replaceAll = function(f, e) {\n  let reg = new RegExp(f, \"g\");  \n  return this.replace(reg, e); \n}\n\nString.prototype.removeStrByIndex = function(start, end) {\n  let firstStr = this.slice(0, start);\n  let lastStr = this.slice(end + 1);\n  return firstStr + lastStr;\n}\n\nconst util = {\n  logg: function(content) {\n    console.log('--------------------------------------------\\n');\n    console.log(content);\n    console.log();\n    console.log('--------------------------------------------\\n');\n  },\n\n  errLogg: function(func, content) {\n    console.log(\"-------------error------------\\n\");\n    console.error(`${func}: ${content}`);\n    console.log();\n    console.log('-------------error------------\\n');\n  }\n}\n\nmodule.exports = util;","const NOTFUNC = /^(if|else|else if|for|while)[\\s]*$/;\nconst BASEFUNC = /^(print|printf)[\\s]*$/;\nconst shorChar = ['c', 'i', 's', 'l', 'd', 'f', 'b'];\n\nconst common = {\n  isState: function(char, current, input) {\n\n    let str = input.slice(current, current + 7);\n  \n    if(str.indexOf(\"char\") != -1 || str.indexOf(\"int\") != -1 || str.indexOf(\"short\") != -1 || str.indexOf(\"long\") != -1 || str.indexOf(\"double\") != -1 || str.indexOf(\"float\") != -1 || str.indexOf(\"string\") != -1 || str.indexOf(\"bool\") != -1) {\n      if(!shorChar.includes(char)){\n        return false;\n      }\n      if(str.indexOf(' ') === -1) {\n        return false;\n      }\n      return true;\n    }\n\n    str = input.slice(current, current + 10);\n    if(str.indexOf(\"long long\") != -1 || str.indexOf(\"long double\") != -1) {\n      if(char != 'l') {\n        return false;\n      }\n      if(str.indexOf(' ') === -1) {\n        return false;\n      }\n      return true;\n    }\n\n    return false;\n  },\n\n  isNotFunc: function(name) {\n    if(NOTFUNC.test(name)) {\n      return true;\n    }\n\n    // 是函数\n    return false;\n  },\n\n  isBaseFunc: function(name) {\n    if(BASEFUNC.test(name)) {\n      return name;\n    }\n\n    return false;\n  },\n\n  isExistFunc: function(name) {\n    if(name.includes('=')) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\nmodule.exports = common;","const FUNC_NAME_MAP = {\n  'printf': 'console.log'\n}\n\nmodule.exports = FUNC_NAME_MAP;\n","const FUNC_HANDLE_MAP = {\n  printf: function(arg) {\n    let lastQuoIndex = arg.lastIndexOf('\"');\n    let paramStr = '';\n\n    // 获取后面参数，+2跳过引号和逗号, 最后再去掉空格\n    let argStr = arg.slice(lastQuoIndex + 2, arg.length).replaceAll(' ', '');\n\n    // 获取参数数组\n    let argArr = argStr.split(',')\n\n    let percentage = arg.indexOf('%');\n\n    // 起始为1跳过引号\n    let argIndex = 0;\n\n    if (percentage === -1) {\n      // 没有参数则直接返回字符串\n      paramStr = arg;\n    } else {\n      while (percentage != -1) {\n        // 用加号拼接str和参数\n        paramStr += `'${arg.slice(1, percentage)}' + ${argArr[argIndex]}`\n  \n        // 将之前的字符串截取出去\n        arg = arg.slice(percentage + 1, arg.length);\n  \n        // 获取下一个占位符\n        percentage = arg.indexOf('%');\n        \n        // 参数数组自增\n        argIndex++;\n  \n        if(percentage != -1) {\n          paramStr += ' + ';\n        }\n      }\n    }\n    \n    return paramStr;\n  }\n}\n\nmodule.exports = FUNC_HANDLE_MAP;\n","const util = require('./util');\nconst common = require('./common');\nconst FUNC_NAME_MAP = require('./func-name-map');\nconst FUNC_HANDLE_MAP = require('./func-handle-map');\n\nconst input = \n`\n#include \"stdlib.h\"\n\nint add(a,b){\n  int sum = a + b;\n  return sum;\n};\nint main() {\n  string str = \"hello world\";\n  int a = 3, b = 1;\n  int res = add(a, b);\n  if( res > a ) {\n    printf(\"the result is %d\", res);\n  } else {\n    printf(\"%s\", str);\n  };\n  return 0;\n}`\n\nconst WHITESPACE = /\\s/;\nconst WORD = /[a-z0-9 | :~,'\"%=+/\\-*/^></\\[/\\]!.&]/i;\nconst NEWLINE = '\\n';\n\nlet isParWord = false; // 是否为出现在字符串中的括号， 若存在则不单独匹配成一个括号\n\n// 字符串转token\nfunction tokenizer(input) {\n  // 字符串当前位置\n  let current = 0;\n\n  // 存放token\n  let tokens = [];\n\n  // 循环输入的字符串\n  while (current < input.length) {\n    \n    // 获取当前字符\n    let char = input[current];\n\n    // 检查是否为声明\n    if (common.isState(char, current, input)) {\n      // 获取声明后空格索引\n      let temp_index = input.slice(current, current + 10).indexOf(' ');\n      // 获取声明\n      \n      current = current + temp_index + 1;\n\n      tokens.push({\n        type: 'state',\n        value: 'var'\n      });\n\n      continue;\n    }\n    // 检查是否为括号\n    if (char === '(') {\n      isParWord = true; // 在括号中\n\n      // token添加\n      tokens.push({\n        type: 'paren',\n        value: '('\n      })\n      // 继续循环\n      current++;\n      continue;\n    }\n    \n    if (char === ')') {\n      isParWord = false; // 括号结束\n\n      tokens.push({\n        type: 'paren',\n        value: ')'\n      })\n      current++;\n      continue;\n    }\n\n    // 检查是否为大括号\n    if (char === '{') {\n      tokens.push({\n        type: 'parenb',\n        value: '{'\n      })\n      current++;\n      continue;\n    }\n\n    if (char === '}') {\n      tokens.push({\n        type: 'parenb',\n        value: '}'\n      })\n      current++;\n      continue;\n    }\n\n    // 检查是否为分号\n    if (char === ';') {\n      tokens.push({\n        type: 'semicolon',\n        value: ';'\n      })\n      current++;\n      continue;\n    }\n\n    // 检查是否为换行\n    if (char === NEWLINE) {\n      tokens.push({\n        type: 'newline',\n        value: '\\n'\n      })\n    }\n\n    // 检查是否为空格\n    if (WHITESPACE.test(char)) {\n      tokens.push({\n        type: 'whitespace',\n        value: ' '\n      })\n      current++;\n      continue;\n    }\n\n    // 检查是否为字符\n    if (WORD.test(char)) {\n      let word_str = '';\n\n      // 直到遇到非字符，如果为字符串中的左括号或者右括号也加入字符串中\n      // 左括号通过之前的起始(来判断是否在字符串中\n      // 右括号通过判断其后面是否有'来确认是否为终结括号\n      while((WORD.test(char) && char) || (char === '(' && isParWord) || (char === ')' && input[current + 1] === \"'\")) {\n        word_str += char;\n        char = input[++current];\n      }\n\n      tokens.push({\n        type: 'string',\n        value: word_str\n      })\n\n      continue;\n    }\n\n    // 检查是否为库声明\n    if (char === '#') {\n      while(char != '\\n') {\n        char = input[++current];\n      }\n\n      continue;\n    }\n\n    current++;\n  }\n\n  return tokens;\n}\n\nlet isArr = false;\n\n// tokens转ast\nfunction parser(tokens) {\n  let current = 0;\n\n  let temp_ast;\n  // 递归遍历\n  function getAst() {\n    // 遍历token数组\n\n    let token = tokens[current];\n\n    // 判断是否为string类型\n    if(token.type === 'string') {\n      current++;\n      \n      // 判断后面是否为函数\n      let next_token = tokens[current];\n      if(next_token && next_token.type === 'paren' && next_token.value === '(') {\n        return null;\n      }\n\n      // 是否为数组声明\n\n      // 是否为初始赋值的数组\n      let isAssignArr = (next_token && next_token.type === 'parenb' && next_token.value === '{' && tokens[current - 1].value.search('=') != -1);\n\n      // 是否为为赋值数组\n\n      let notAssignArr = (tokens[current - 2] && tokens[current - 2].type === 'state' && tokens[current - 1].value.indexOf('[') != -1 && tokens[current - 1].value.indexOf(']') != -1);\n      if(isAssignArr || notAssignArr) {\n        let curValue = tokens[current - 1].value;\n        let arrValue = curValue.removeStrByIndex(curValue.indexOf('['), curValue.indexOf(']'));\n\n        tokens[current - 1].value = arrValue;\n        console.log(arrValue)\n      }\n      // 否则返回string\n      return {\n        type: 'StringLiteral',\n        value: token.value\n      }\n    }\n\n    if(token.type === 'semicolon') {\n      current++;\n\n      return {\n        type: 'SemLiteral',\n        value: token.value\n      }\n    }\n\n    if(token.type === 'whitespace') {\n      current++;\n\n      return {\n        type: 'WhiteLiteral',\n        value: token.value\n      }\n    }\n\n    if(token.type === 'newline') {\n      current++;\n\n      return {\n        type: 'LineLiteral',\n        value: token.value\n      }\n    }\n\n    // 判断是否为类型声明\n    if(token.type === 'state') {\n      current++;\n\n      return {\n        type: 'StateLiteral',\n        value: token.value\n      }\n    }\n\n    // 判断是否为大括号 其中判断是否为数组声明\n    if (token.type === 'parenb' && (token.value === '{' || token.value === '}')) {\n      let value = token.value;\n      if((tokens[current - 1].type === 'string' && tokens[current - 1].value.search('=') != -1) || isArr){\n        isArr = true;\n        if(token.value === '{'){\n          value = '[';\n        } else if (token.value === '}') {\n          value = ']';\n          isArr = false;\n        }\n      }\n      \n      current++;\n\n      return {\n        type: 'ParenbLiteral',\n        value: value\n      };\n    }\n\n\n    // 判断是否为括号\n    if(token.type === 'paren' && token.value === '(') {\n      // 创建CallExpression节点\n      let node = {\n        type: 'CallExpression',\n        params: [],\n        name: '',\n        isFunc: true,\n        isBaseFunc: true,\n        isExistFunc: false\n      }\n\n      // 获取函数名\n      let pre_index = current - 1;\n      let pre_token = tokens[pre_index];\n\n      if(pre_token.type === 'string') {\n        node.name = pre_token.value;\n\n        // 判断是否为函数\n        let isNotFunc = common.isNotFunc(node.name);\n\n        if(isNotFunc) {\n          node.isFunc = false;\n        } else {\n          // 判断是否为基本函数\n          let isBaseFunc = common.isBaseFunc(node.name);\n\n          if(!isBaseFunc) {\n            ast.body.removeByLastValObj('var');\n            node.isBaseFunc = false;\n          }\n\n          // 判断是否为已有函数\n          let isExistFunc = common.isExistFunc(node.name);\n          if(isExistFunc) {\n            node.isExistFunc = true;\n          }\n        }\n      }\n      \n      // 删除函数前面的state声明\n\n      // 跳过括号并且获取下一个token\n      token = tokens[++current];\n\n      let tempAst; // 暂存参数\n\n      // 继续遍历直到遇到右括号\n      while ((token.type !== 'paren') || (token.type === 'paren' && token.value !== ')')) {\n        // 参数放入params\n        tempAst = getAst();\n        if(tempAst.type === 'StateLiteral') continue;\n\n        node.params.push(tempAst);\n\n        token = tokens[current];\n\n        if(!token) {\n          util.errLogg('parser过程出错', `存在括号未闭合错误<${current}>`);\n          break;\n        }\n      }\n      // 跳过右括号\n      current++;\n      return node;\n    }\n\n    util.errLogg('parser过程出错', `发现未知类型${token.type}`);\n\n    current++;\n    return;\n  }\n\n  // 创建ast\n  let ast = {\n    type: 'Program',\n    body: []\n  }\n\n  while(current < tokens.length) {\n    temp_ast = getAst();\n    if(temp_ast) ast.body.push(temp_ast);\n  }\n\n  return ast;\n}\n\n\n// 遍历ast处理节点\nfunction astTraver(ast, visitor) {\n\n  function nodeArrTraver(arr, parent) {\n    arr.forEach(function(child) {\n      nodeTraver(child, parent)\n    })\n  }\n\n  function nodeTraver(node, parent) {\n\n    if (!node) {\n      util.errLogg('astTraver过程出错', `括号未闭合或出现未知类型<${parent.type}>`);\n      return;\n    }\n\n    // 获取当前节点处理函数\n    let method = visitor[node.type];\n\n    if(method) {\n      method(node, parent)\n    }\n\n    switch (node.type) {\n      // 顶层，遍历其子元素数组\n      case 'Program':\n        nodeArrTraver(node.body, node);\n        break;\n      \n      // 函数, 遍历其参数数组\n      case 'CallExpression':\n        nodeArrTraver(node.params, node);\n        break;\n      \n      // string, state等没有子节点，跳过\n      case 'StringLiteral':\n        break;\n\n      case 'StateLiteral':\n        break;\n\n      case 'SemLiteral':\n        break;\n      \n      case 'WhiteLiteral':\n        break;\n\n      case 'LineLiteral':\n        break;\n\n      case 'ParenbLiteral':\n        break;\n      \n      default:\n        util.errLogg('astTraver过程出错', `发现未知类型${node.type}`);\n    }\n  }\n\n  // 从头遍历ast\n  nodeTraver(ast, null);\n}\n\n// 将ast和traver传入得到新的ast\nfunction transformer(ast) {\n  // 创建新的根节点\n  let newAst = {\n    type: 'Program',\n    body: []\n  };\n\n  // 在根节点上创建context上下文，用来存放节点\n  // context是一个引用，从旧的ast到新的\n  ast._context = newAst.body;\n\n  astTraver(ast, {\n    // 处理string\n    StringLiteral: function(node, parent) {\n      // 创建新节点放入父节点context\n      parent._context.push({\n        type: 'StringLiteral',\n        value: node.value\n      });\n    },\n\n    // 处理state\n    StateLiteral: function(node, parent) {\n      parent._context.push({\n        type: 'StateLiteral',\n        value: node.value\n      });\n    },\n\n    // 处理分号\n    SemLiteral: function(node, parent) {\n      parent._context.push({\n        type: 'SemLiteral',\n        value: node.value\n      })\n    },\n\n    // 处理空格\n    WhiteLiteral: function(node, parent) {\n      parent._context.push({\n        type: 'WhiteLiteral',\n        value: node.value\n      })\n    },\n\n    LineLiteral: function(node, parent) {\n      parent._context.push({\n        type: 'LineLiteral',\n        value: node.value\n      })\n    },\n\n    // 处理大括号\n    ParenbLiteral: function(node, parent) {\n      parent._context.push({\n        type: 'ParenbLiteral',\n        value: node.value\n      })\n    },\n\n    // 处理函数\n    CallExpression: function(node, parent) {\n      // 创建CallExpression节点，内嵌套Identifier\n      let expression = {\n        type: 'CallExpression',\n        callee: {\n          type: 'Identifier',\n          name: node.name\n        },\n        isFunc: node.isFunc,\n        isBaseFunc: node.isBaseFunc,\n        isExistFunc: node.isExistFunc,\n        arguments: []\n      };\n\n      // 在CallExpression上创建context, 他是arguments的引用\n      node._context = expression.arguments;\n\n      // 判断父节点是否为函数\n      if(parent.type != 'CallExpression') {\n        expression = {\n          type: 'ExpressionStatement',\n          expression: expression\n        }\n      }\n\n      parent._context.push(expression);\n    }\n\n  });\n\n  return newAst;\n}\n\nlet notFunc = true; // 标记是否为if,else,for,while\n\n// 打印ast中节点拼接成字符串\nfunction generator(node) {\n  switch (node.type) {\n    // 遍历根节点所有子元素\n    case 'Program':\n      return node.body.map(generator).join('');\n    \n    // 对于ExpressionStatements，递归调用其属性并加入分号\n    case 'ExpressionStatement':\n      return (\n        generator(node.expression)\n      )\n\n    // 对于CallExpressions，我们打印出callee和左括号，然后递归调用其参数，最后加上右括号\n    case 'CallExpression':\n      notFunc = false; // 设为false 检测到此值分号不换行\n      let funcName = generator(node.callee);\n      let argArr = node.arguments.map(generator);\n      let res;\n\n      // 是函数\n      if(node.isFunc) {\n        if(node.isBaseFunc) {\n          // 如果是基本函数\n          let paramStr = FUNC_HANDLE_MAP[funcName](argArr.join(''));\n          res = `${FUNC_NAME_MAP[funcName]}(${paramStr})`;\n        } else if(node.isExistFunc) {\n          //如果是已存在函数\n          res = `var ${funcName}(${argArr.join(', ')})`;\n        } else {\n          res = `function ${funcName}(${argArr.join(', ')})`;\n        }\n      } else {\n        // 不是函数\n        res = `${funcName}(${argArr.join('')})`;\n      }\n\n      notFunc = true;\n      return res;\n  \n    // 返回name\n    case 'Identifier':\n      return node.name;\n    \n    // 返回value\n    case 'NumberLiteral':\n      return node.value;\n    \n    case 'StringLiteral':\n      return node.value;\n    \n    case 'StateLiteral':\n      return node.value + ' ';\n    \n    case 'SemLiteral':\n      return ';';\n    \n    case 'WhiteLiteral':\n      return ' ';\n    \n    case 'LineLiteral':\n      return '\\n';\n\n    case 'ParenbLiteral':\n      return node.value;\n\n    default:\n      util.errLogg('generator过程出错', `发现未知类型${node.type}`);\n  }\n}\n\nfunction compiler(input) {\n  let tokens = tokenizer(input);\n  util.logg(tokens);\n  let ast = parser(tokens);\n  util.logg(ast);\n  let newAst = transformer(ast);\n  util.logg(newAst);\n  let output = generator(newAst);\n  // util.logg(output);\n  return output;\n}\n\n// compiler(input);\n\nmodule.exports = compiler;\n","const compiler = require('./index');\n\nlet input = `#include \"stdio.h\";\nint add(int a,b){\n  int sum = a + b;\n  return sum;\n};\nint main() {\n  string str = \"hello world\";\n  int a = 3, b = 1;\n  int res = add(a, b);\n  if( res > a ) {\n    printf(\"the result is %d\", res);\n  } else {\n    printf(\"%s\", str);\n  };\n  return 0;\n}`;\n\nlet test = `int a[10];\nint a[5] = {1, 3, 4}`\n\ndocument.getElementById('input').value = input;\n\ndocument.getElementById('transformBtn').addEventListener('click', function() {\n  let value = document.getElementById('input').value;\n  let output = compiler(value);\n  document.getElementById('output').value = output;\n})\n\ndocument.getElementById('executeBtn').addEventListener('click', function() {\n  let value = document.getElementById('output').value;\n  value += `\\nmain();`;\n  try {\n    let log = eval(value);\n    document.getElementById('log').value = log;\n  } catch (err) {\n    alert(err);\n  }\n})"]}